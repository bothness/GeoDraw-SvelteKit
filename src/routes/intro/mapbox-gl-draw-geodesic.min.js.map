{"version":3,"file":"mapbox-gl-draw-geodesic.min.js","sources":["../node_modules/@mapbox/mapbox-gl-draw/src/constants.js","../src/constants.js","../node_modules/hat/index.js","../src/utils/circle_geojson.js","../node_modules/arc/arc.js","../node_modules/arc/index.js","../src/utils/create_geodesic_line.js","../node_modules/geodesy-fn/src/common.js","../node_modules/geodesy-fn/src/spherical.js","../node_modules/geodesy-fn/src/dms.js","../src/utils/geodesy.js","../src/utils/create_geodesic_geojson.js","../src/utils/create_geodesic_circle.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","../src/modes/draw_line_string.js","../src/modes/draw_polygon.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","../src/utils/drag_pan.js","../src/modes/draw_circle.js","../src/modes/draw_point.js","../src/modes/simple_select.js","../src/modes/direct_select.js","../node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","../src/modes/static.js","../src/modes/index.js"],"sourcesContent":["export const classes = {\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select',\n  STATIC: 'static'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","import { modes as originalModes } from '@mapbox/mapbox-gl-draw/src/constants';\nexport { cursors, geojsonTypes, events, meta, activeStates } from '@mapbox/mapbox-gl-draw/src/constants';\n\nexport const modes = {\n    ...originalModes,\n    DRAW_CIRCLE: 'draw_circle'\n};\n\nexport const properties = {\n    CIRCLE_RADIUS: 'circleRadius',\n    CIRCLE_HANDLE_BEARING: 'circleHandleBearing'\n};","var hat = module.exports = function (bits, base) {\n    if (!base) base = 16;\n    if (bits === undefined) bits = 128;\n    if (bits <= 0) return '0';\n    \n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    for (var i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n    \n    var rem = digits - Math.floor(digits);\n    \n    var res = '';\n    \n    for (var i = 0; i < Math.floor(digits); i++) {\n        var x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n    \n    if (rem) {\n        var b = Math.pow(base, rem);\n        var x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n    \n    var parsed = parseInt(res, base);\n    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n        return hat(bits, base)\n    }\n    else return res;\n};\n\nhat.rack = function (bits, base, expandBy) {\n    var fn = function (data) {\n        var iters = 0;\n        do {\n            if (iters ++ > 10) {\n                if (expandBy) bits += expandBy;\n                else throw new Error('too many ID collisions, use more bits')\n            }\n            \n            var id = hat(bits, base);\n        } while (Object.hasOwnProperty.call(hats, id));\n        \n        hats[id] = data;\n        return id;\n    };\n    var hats = fn.hats = {};\n    \n    fn.get = function (id) {\n        return fn.hats[id];\n    };\n    \n    fn.set = function (id, value) {\n        fn.hats[id] = value;\n        return fn;\n    };\n    \n    fn.bits = bits || 128;\n    fn.base = base || 16;\n    return fn;\n};\n","import hat from 'hat';\nimport * as Constants from '../constants';\n\nexport function createCircle(center, radius, properties = {}) {\n  if (!(radius > 0)) {\n    throw new Error('Radius has to be greater then 0');\n  }\n\n  return {\n    id: hat(),\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      [Constants.properties.CIRCLE_RADIUS]: radius, // km\n      ...properties\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[center, center, center, center]] // valid polygon needs 3 vertices\n    }\n  };\n}\n\nexport function isCircle(geojson) {\n  return geojson.geometry.type === Constants.geojsonTypes.POLYGON &&\n    typeof geojson.properties[Constants.properties.CIRCLE_RADIUS] === 'number' &&\n    geojson.properties[Constants.properties.CIRCLE_RADIUS] > 0;\n}\n\nexport function getCircleCenter(geojson) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  return geojson.geometry.coordinates[0][0];\n}\n\nexport function setCircleCenter(geojson, center) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  geojson.geometry.coordinates = [[center, center, center, center]]; // valid polygon needs 3 vertices\n}\n\nexport function getCircleRadius(geojson) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  return geojson.properties[Constants.properties.CIRCLE_RADIUS];\n}\n\nexport function setCircleRadius(geojson, radius) {\n  if (!isCircle(geojson)) {\n    throw new Error('GeoJSON is not a circle');\n  }\n\n  geojson.properties[Constants.properties.CIRCLE_RADIUS] = radius;\n}","'use strict';\n\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function(lon,lat) {\n    this.lon = lon;\n    this.lat = lat;\n    this.x = D2R * lon;\n    this.y = D2R * lat;\n};\n\nCoord.prototype.view = function() {\n    return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function() {\n    var anti_lat = -1 * this.lat;\n    var anti_lon = (this.lon < 0) ? 180 + this.lon : (180 - this.lon) * -1;\n    return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function() {\n    this.coords = [];\n    this.length = 0;\n};\n\nLineString.prototype.move_to = function(coord) {\n    this.length++;\n    this.coords.push(coord);\n};\n\nvar Arc = function(properties) {\n    this.properties = properties || {};\n    this.geometries = [];\n};\n\nArc.prototype.json = function() {\n    if (this.geometries.length <= 0) {\n        return {'geometry': { 'type': 'LineString', 'coordinates': null },\n                'type': 'Feature', 'properties': this.properties\n               };\n    } else if (this.geometries.length == 1) {\n        return {'geometry': { 'type': 'LineString', 'coordinates': this.geometries[0].coords },\n                'type': 'Feature', 'properties': this.properties\n               };\n    } else {\n        var multiline = [];\n        for (var i = 0; i < this.geometries.length; i++) {\n            multiline.push(this.geometries[i].coords);\n        }\n        return {'geometry': { 'type': 'MultiLineString', 'coordinates': multiline },\n                'type': 'Feature', 'properties': this.properties\n               };\n    }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function() {\n    var wkt_string = '';\n    var wkt = 'LINESTRING(';\n    var collect = function(c) { wkt += c[0] + ' ' + c[1] + ','; };\n    for (var i = 0; i < this.geometries.length; i++) {\n        if (this.geometries[i].coords.length === 0) {\n            return 'LINESTRING(empty)';\n        } else {\n            var coords = this.geometries[i].coords;\n            coords.forEach(collect);\n            wkt_string += wkt.substring(0, wkt.length - 1) + ')';\n        }\n    }\n    return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function(start,end,properties) {\n    if (!start || start.x === undefined || start.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    if (!end || end.x === undefined || end.y === undefined) {\n        throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n    }\n    this.start = new Coord(start.x,start.y);\n    this.end = new Coord(end.x,end.y);\n    this.properties = properties || {};\n\n    var w = this.start.x - this.end.x;\n    var h = this.start.y - this.end.y;\n    var z = Math.pow(Math.sin(h / 2.0), 2) +\n                Math.cos(this.start.y) *\n                   Math.cos(this.end.y) *\n                     Math.pow(Math.sin(w / 2.0), 2);\n    this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n    if (this.g == Math.PI) {\n        throw new Error('it appears ' + start.view() + ' and ' + end.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n    } else if (isNaN(this.g)) {\n        throw new Error('could not calculate great circle between ' + start + ' and ' + end);\n    }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function(f) {\n    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n    var B = Math.sin(f * this.g) / Math.sin(this.g);\n    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);\n    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);\n    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n    var lon = R2D * Math.atan2(y, x);\n    return [lon, lat];\n};\n\n\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function(npoints,options) {\n    var first_pass = [];\n    if (!npoints || npoints <= 2) {\n        first_pass.push([this.start.lon, this.start.lat]);\n        first_pass.push([this.end.lon, this.end.lat]);\n    } else {\n        var delta = 1.0 / (npoints - 1);\n        for (var i = 0; i < npoints; ++i) {\n            var step = delta * i;\n            var pair = this.interpolate(step);\n            first_pass.push(pair);\n        }\n    }\n    /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n\n      TODO - does not handle all wrapping scenarios yet\n    */\n    var bHasBigDiff = false;\n    var dfMaxSmallDiffLong = 0;\n    // from http://www.gdal.org/ogr2ogr.html\n    // -datelineoffset:\n    // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n    var dfDateLineOffset = options && options.offset ? options.offset : 10;\n    var dfLeftBorderX = 180 - dfDateLineOffset;\n    var dfRightBorderX = -180 + dfDateLineOffset;\n    var dfDiffSpace = 360 - dfDateLineOffset;\n\n    // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n    for (var j = 1; j < first_pass.length; ++j) {\n        var dfPrevX = first_pass[j-1][0];\n        var dfX = first_pass[j][0];\n        var dfDiffLong = Math.abs(dfX - dfPrevX);\n        if (dfDiffLong > dfDiffSpace &&\n            ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) || (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))) {\n            bHasBigDiff = true;\n        } else if (dfDiffLong > dfMaxSmallDiffLong) {\n            dfMaxSmallDiffLong = dfDiffLong;\n        }\n    }\n\n    var poMulti = [];\n    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n        var poNewLS = [];\n        poMulti.push(poNewLS);\n        for (var k = 0; k < first_pass.length; ++k) {\n            var dfX0 = parseFloat(first_pass[k][0]);\n            if (k > 0 &&  Math.abs(dfX0 - first_pass[k-1][0]) > dfDiffSpace) {\n                var dfX1 = parseFloat(first_pass[k-1][0]);\n                var dfY1 = parseFloat(first_pass[k-1][1]);\n                var dfX2 = parseFloat(first_pass[k][0]);\n                var dfY2 = parseFloat(first_pass[k][1]);\n                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 == 180 &&\n                    k+1 < first_pass.length &&\n                   first_pass[k-1][0] > -180 && first_pass[k-1][0] < dfRightBorderX)\n                {\n                     poNewLS.push([-180, first_pass[k][1]]);\n                     k++;\n                     poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                     continue;\n                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 == -180 &&\n                     k+1 < first_pass.length &&\n                     first_pass[k-1][0] > dfLeftBorderX && first_pass[k-1][0] < 180)\n                {\n                     poNewLS.push([180, first_pass[k][1]]);\n                     k++;\n                     poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n                     continue;\n                }\n\n                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX)\n                {\n                    // swap dfX1, dfX2\n                    var tmpX = dfX1;\n                    dfX1 = dfX2;\n                    dfX2 = tmpX;\n                    // swap dfY1, dfY2\n                    var tmpY = dfY1;\n                    dfY1 = dfY2;\n                    dfY2 = tmpY;\n                }\n                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n                    dfX2 += 360;\n                }\n\n                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2)\n                {\n                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n                    poNewLS.push([first_pass[k-1][0] > dfLeftBorderX ? 180 : -180, dfY]);\n                    poNewLS = [];\n                    poNewLS.push([first_pass[k-1][0] > dfLeftBorderX ? -180 : 180, dfY]);\n                    poMulti.push(poNewLS);\n                }\n                else\n                {\n                    poNewLS = [];\n                    poMulti.push(poNewLS);\n                }\n                poNewLS.push([dfX0, first_pass[k][1]]);\n            } else {\n                poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n            }\n        }\n    } else {\n        // add normally\n        var poNewLS0 = [];\n        poMulti.push(poNewLS0);\n        for (var l = 0; l < first_pass.length; ++l) {\n            poNewLS0.push([first_pass[l][0],first_pass[l][1]]);\n        }\n    }\n\n    var arc = new Arc(this.properties);\n    for (var m = 0; m < poMulti.length; ++m) {\n        var line = new LineString();\n        arc.geometries.push(line);\n        var points = poMulti[m];\n        for (var j0 = 0; j0 < points.length; ++j0) {\n            line.move_to(points[j0]);\n        }\n    }\n    return arc;\n};\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n  // nodejs\n  module.exports.Coord = Coord;\n  module.exports.Arc = Arc;\n  module.exports.GreatCircle = GreatCircle;\n\n} else {\n  // browser\n  var arc = {};\n  arc.Coord = Coord;\n  arc.Arc = Arc;\n  arc.GreatCircle = GreatCircle;\n}\n","module.exports = require('./arc');\n","import arc from 'arc';\nimport * as Constants from '../constants';\n\nfunction coordinatesEqual(x, y) {\n  return x[0] === y[0] && x[1] === y[1];\n}\n\nfunction coordinatePairs(array) {\n  return array.slice(0, -1)\n    .map((value, index) => [value, array[index + 1]])\n    .filter(pair => !coordinatesEqual(pair[0], pair[1]));\n}\n  \nfunction createGeodesicLine(coordinates, steps = 32) {\n  const segments = coordinatePairs(coordinates);\n\n  const geodesicSegments = segments.map(segment => {\n    const greatCircle = new arc.GreatCircle(\n      { x: segment[0][0], y: segment[0][1] },\n      { x: segment[1][0], y: segment[1][1] }\n    );\n    return greatCircle.Arc(steps, { offset: 90 }).json();\n  });\n\n  // arc.js returns the line crossing antimeridian split into two MultiLineString segments\n  // (the first going towards to antimeridian, the second going away from antimeridian, both in range -180..180 longitude)\n  // fix Mapbox rendering by merging them together, adding 360 to longitudes on the right side\n  let worldOffset = 0;\n  const geodesicCoordinates = geodesicSegments.map(geodesicSegment => {\n    if (geodesicSegment.geometry.type === Constants.geojsonTypes.MULTI_LINE_STRING) {\n      const prevWorldOffset = worldOffset;\n      const nextWorldOffset = worldOffset + (geodesicSegment.geometry.coordinates[0][0][0] > geodesicSegment.geometry.coordinates[1][0][0] ? 1 : -1);\n      const geodesicCoordinates = [\n        ...geodesicSegment.geometry.coordinates[0].map(x => [x[0] + prevWorldOffset * 360, x[1]]),\n        ...geodesicSegment.geometry.coordinates[1].map(x => [x[0] + nextWorldOffset * 360, x[1]])\n      ];\n      worldOffset = nextWorldOffset;\n      return geodesicCoordinates;\n    } else {\n      const geodesicCoordinates = geodesicSegment.geometry.coordinates.map(x => [x[0] + worldOffset * 360, x[1]]);\n      return geodesicCoordinates;\n    }\n  }).flat();\n\n  return geodesicCoordinates.filter((coord, index) => index === geodesicCoordinates.length - 1 || !coordinatesEqual(coord, geodesicCoordinates[index + 1]));;\n};\n\nexport default createGeodesicLine;","export const DEFAULT_RADIUS = 6371e3;\n\n/**\n * @param {GeoJSON.Position} position1\n * @param {GeoJSON.Position} position2\n * @returns {boolean}\n */\nexport function equals(position1, position2) {\n  if (Math.abs(position1[0] - position2[0]) > Number.EPSILON) return false;\n  if (Math.abs(position1[1] - position2[1]) > Number.EPSILON) return false;\n\n  return true;\n}\n\n/**\n * @param {number} value\n * @returns {number}\n */\nexport function toRadians(value) {\n  return value / 180 * Math.PI;\n}\n\n/**\n * @param {number} value\n * @returns {number}\n */\nexport function toDegrees(value) {\n  return value / Math.PI * 180;\n}","import { DEFAULT_RADIUS, equals, toRadians, toDegrees } from './common.js';\nimport { wrap360 } from './dms.js';\n\n/**\n * Returns the distance along the surface of the earth from start point to destination point.\n *\n * Uses haversine formula: a = sin²(Δφ/2) + cosφ1·cosφ2 · sin²(Δλ/2); d = 2 · atan2(√a, √(a-1)).\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @param   {number} [radius] - Radius of earth (defaults to mean radius in metres).\n * @returns {number} Distance between start point and destination point, in same units as radius.\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const d = distance(p1, p2);         // 404.3×10³ m\n *   const m = distanceTo(p1, p2, 3959); // 251.2 miles\n */\nexport function distance(start, destination, radius = DEFAULT_RADIUS) {\n  // a = sin²(Δφ/2) + cos(φ1)⋅cos(φ2)⋅sin²(Δλ/2)\n  // δ = 2·atan2(√(a), √(1−a))\n  // see mathforum.org/library/drmath/view/51879.html for derivation\n\n  const R = radius;\n  const φ1 = toRadians(start[1]),       λ1 = toRadians(start[0]);\n  const φ2 = toRadians(destination[1]), λ2 = toRadians(destination[0]);\n  const Δφ = φ2 - φ1;\n  const Δλ = λ2 - λ1;\n\n  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const d = R * c;\n\n  return d;\n}\n\n/**\n * Returns the initial bearing from start point to destination point.\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @returns {number} Initial bearing in degrees from north (0°..360°).\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const b1 = initialBearing(p1, p2); // 156.2°\n */\nexport function initialBearing(start, destination) {\n  if (equals(start, destination)) return NaN; // coincident points\n\n  // tanθ = sinΔλ⋅cosφ2 / cosφ1⋅sinφ2 − sinφ1⋅cosφ2⋅cosΔλ\n  // see mathforum.org/library/drmath/view/55417.html for derivation\n\n  const φ1 = toRadians(start[1]);\n  const φ2 = toRadians(destination[1]);\n  const Δλ = toRadians(destination[0] - start[0]);\n\n  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n  const y = Math.sin(Δλ) * Math.cos(φ2);\n  const θ = Math.atan2(y, x);\n\n  const bearing = toDegrees(θ);\n\n  return wrap360(bearing);\n}\n\n/**\n * Returns final bearing arriving at destination point from ‘this’ point; the final bearing will\n * differ from the initial bearing by varying degrees according to distance and latitude.\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @returns {number} Final bearing in degrees from north (0°..360°).\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const b2 = finalBearing(p1, p2); // 157.9°\n */\nexport function finalBearing(start, destination) {\n  // get initial bearing from destination point to this point & reverse it by adding 180°\n\n  const bearing = initialBearing(destination, start) + 180;\n\n  return wrap360(bearing);\n}\n\n/**\n * Returns the midpoint between start point and destination point.\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {GeoJSON.Position} destination - Longitude/latitude of destination point.\n * @returns {GeoJSON.Position} Midpoint between this point and destination point.\n *\n * @example\n *   const p1 = [0.119, 52.205];\n *   const p2 = [2.351, 48.857];\n *   const pMid = midpoint(p1, p2); // [1.2746, 50.5363]\n */\nexport function midpoint(start, destination) {\n  // φm = atan2( sinφ1 + sinφ2, √( (cosφ1 + cosφ2⋅cosΔλ)² + cos²φ2⋅sin²Δλ ) )\n  // λm = λ1 + atan2(cosφ2⋅sinΔλ, cosφ1 + cosφ2⋅cosΔλ)\n  // midpoint is sum of vectors to two points: mathforum.org/library/drmath/view/51822.html\n\n  const φ1 = toRadians(start[1]);\n  const λ1 = toRadians(start[0])\n  const φ2 = toRadians(destination[1]);\n  const Δλ = toRadians(destination[0] - start[0]);\n\n  // get cartesian coordinates for the two points\n  const A = { x: Math.cos(φ1), y: 0, z: Math.sin(φ1) }; // place point A on prime meridian y=0\n  const B = { x: Math.cos(φ2)*Math.cos(Δλ), y: Math.cos(φ2)*Math.sin(Δλ), z: Math.sin(φ2) };\n\n  // vector to midpoint is sum of vectors to two points (no need to normalise)\n  const C = { x: A.x + B.x, y: A.y + B.y, z: A.z + B.z };\n\n  const φm = Math.atan2(C.z, Math.sqrt(C.x*C.x + C.y*C.y));\n  const λm = λ1 + Math.atan2(C.y, C.x);\n\n  const lat = toDegrees(φm);\n  const lon = toDegrees(λm);\n\n  return [lon, lat];\n}\n\n/**\n * Returns the destination point from start point having travelled the given distance on the\n * given initial bearing (bearing normally varies around path followed).\n *\n * @param   {GeoJSON.Position} start - Longitude/latitude of start point.\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n * @param   {number} bearing - Initial bearing in degrees from north.\n * @param   {number} [radius] - Radius of earth (defaults to mean radius in metres).\n * @returns {GeoJSON.Position} Destination point.\n *\n * @example\n *   const p1 = [-0.00147, 51.47788];\n *   const p2 = destinationPoint(p1, 7794, 300.7); // [0.0983, 51.5136]\n */\nexport function destinationPoint(start, distance, bearing, radius = DEFAULT_RADIUS) {\n  // sinφ2 = sinφ1⋅cosδ + cosφ1⋅sinδ⋅cosθ\n  // tanΔλ = sinθ⋅sinδ⋅cosφ1 / cosδ−sinφ1⋅sinφ2\n  // see mathforum.org/library/drmath/view/52049.html for derivation\n\n  const δ = distance / radius; // angular distance in radians\n  const θ = toRadians(bearing);\n\n  const φ1 = toRadians(start[1]), λ1 = toRadians(start[0]);\n\n  const sinφ2 = Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ);\n  const φ2 = Math.asin(sinφ2);\n  const y = Math.sin(θ) * Math.sin(δ) * Math.cos(φ1);\n  const x = Math.cos(δ) - Math.sin(φ1) * sinφ2;\n  const λ2 = λ1 + Math.atan2(y, x);\n\n  const lat = toDegrees(φ2);\n  const lon = toDegrees(λ2);\n\n  return [lon, lat];\n}","/**\n * @param {number} value\n * @returns {number}\n */\nexport function wrap360(value) {\n  return (value + 360) % 360\n}","import { distance as geodesyDistance, destinationPoint as geodesyDestinationPoint } from 'geodesy-fn/src/spherical';\n\n// radius used by mapbox-gl, see https://github.com/mapbox/mapbox-gl-js/blob/main/src/geo/lng_lat.js#L11\nconst DEFAULT_RADIUS = 6371.0088;\n\nexport function distance(start, destination) {\n  return geodesyDistance(start, destination, DEFAULT_RADIUS);\n}\n\nexport function destinationPoint(start, distance, bearing) {\n  return geodesyDestinationPoint(start, distance, bearing, DEFAULT_RADIUS);\n}\n\nexport { initialBearing, midpoint } from 'geodesy-fn/src/spherical';","import createVertex from '@mapbox/mapbox-gl-draw/src/lib/create_vertex';\nimport * as Constants from '../constants';\nimport { isCircle, getCircleCenter, getCircleRadius } from './circle_geojson';\nimport createGeodesicLine from './create_geodesic_line';\nimport createGeodesicCircle from './create_geodesic_circle';\nimport { midpoint, destinationPoint } from './geodesy';\n\nconst STEPS = 32;\nconst HANDLE_BEARING = 45;\n\nfunction getCoordinate(coordinates, path) {\n  const ids = path.split('.').map(x => parseInt(x, 10));\n  const coordinate = ids.reduce((coordinates, id) => coordinates[id], coordinates);\n  return JSON.parse(JSON.stringify(coordinate));\n}\n\nfunction createGeodesicGeojson(geojson, options) {\n  options = { steps: STEPS, ...options };\n\n  const properties = geojson.properties;\n  const type = geojson.geometry.type;\n  const coordinates = geojson.geometry.coordinates;\n\n  const featureId = properties.parent || properties.id;\n  const feature = options.ctx.store.get(featureId);\n  const featureGeojson = feature.toGeoJSON();\n\n  if (type === Constants.geojsonTypes.POINT) {\n    if ((properties.meta === Constants.meta.VERTEX || properties.meta === Constants.meta.MIDPOINT) && isCircle(featureGeojson)) {\n      return []; // hide circle points, they are displayed in processCircle instead\n    } else if (properties.meta === Constants.meta.MIDPOINT) {\n      return processMidpoint(); // calculate geodesic midpoint\n    } else {\n      return [geojson]; // pass point as is\n    }\n  } else if (type === Constants.geojsonTypes.LINE_STRING) {\n    return processLine(); // calculate geodesic line\n  } else if (type === Constants.geojsonTypes.POLYGON) {\n    if (isCircle(featureGeojson)) {\n      return processCircle(); // calculate geodesic circle\n    } else {\n      return processPolygon(); // calculate geodesic polygon\n    }\n  } else /* istanbul ignore else */ if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {\n    return processMultiGeometry(); \n  }\n\n  function isSelectedPath(path) {\n    if (!options.selectedPaths) {\n      return false;\n    }\n    return options.selectedPaths.indexOf(path) !== -1;\n  }\n\n  function processMidpoint() {\n    const coordPath = properties.coord_path;\n\n    // subtract 1 from the last coord path id\n    const coordPathIds = coordPath.split('.').map(x => parseInt(x, 10));\n    const startCoordPath = coordPathIds.map((x, i) => x + (i === coordPathIds.length - 1 ? -1 : 0)).join('.');\n    const endCoordPath = coordPath;\n\n    const startCoord = getCoordinate(featureGeojson.geometry.coordinates, startCoordPath);\n    const endCoord = getCoordinate(featureGeojson.geometry.coordinates, endCoordPath);\n    const midCoord = midpoint(startCoord, endCoord);\n\n    const geodesicGeojson = {\n      ...geojson,\n      properties: {\n        ...properties,\n        lng: midCoord[0],\n        lat: midCoord[1]\n      },\n      geometry: {\n        ...geojson.geometry,\n        coordinates: midCoord\n      },\n    };\n    return [geodesicGeojson];\n  }\n\n  function processLine() {\n    const geodesicCoordinates = createGeodesicLine(coordinates, options.steps);\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: geodesicCoordinates\n      }\n    };\n    return [geodesicGeojson];\n  }\n\n  function processPolygon() {\n    const geodesicCoordinates = coordinates.map((subCoordinates) => {\n      return createGeodesicLine(subCoordinates);\n    });\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: geodesicCoordinates\n      }\n    };\n    return [geodesicGeojson];\n  }\n\n  function processCircle() {\n    const center = getCircleCenter(featureGeojson);\n    const radius = getCircleRadius(featureGeojson);\n    const handleBearing = feature[Constants.properties.CIRCLE_HANDLE_BEARING] || HANDLE_BEARING;\n    const geodesicCoordinates = createGeodesicCircle(center, radius, handleBearing, options.steps * 4);\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: [geodesicCoordinates]\n      }\n    };\n\n    // circle handles\n    if (properties.active === Constants.activeStates.ACTIVE) {\n      const handle = destinationPoint(center, radius, handleBearing);\n      const points = [center, handle];\n      const vertices = points.map((point, i) => {\n        return createVertex(properties.id, point, `0.${i}`, isSelectedPath(`0.${i}`));\n      })\n  \n      return [geodesicGeojson, ...vertices];\n    } else {\n      return [geodesicGeojson];\n    }\n  }\n\n  function processMultiGeometry() {\n    const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');\n    const geodesicFeatures = coordinates.map((subCoordinates) => {\n      const subFeature = {\n        type: Constants.geojsonTypes.FEATURE,\n        properties: properties,\n        geometry: {\n          type: subType,\n          coordinates: subCoordinates\n        }\n      };\n      return createGeodesicGeojson(subFeature, options);\n    }).flat();\n    const geodesicCoordinates = geodesicFeatures.map((subFeature) => {\n      return subFeature.geometry.coordinates;\n    });\n    const geodesicGeojson = {\n      ...geojson,\n      geometry: {\n        ...geojson.geometry,\n        coordinates: geodesicCoordinates\n      }\n    };\n    return [geodesicGeojson];\n  }\n}\n\nexport default createGeodesicGeojson;","import { destinationPoint } from './geodesy';\n\nfunction createGeodesicCircle(center, radius, bearing, steps) {\n  const coordinates = [];\n  for (let i = 0; i < steps; ++i) {\n    coordinates.push(destinationPoint(center, radius, bearing + (360 * -i) / steps));\n  }\n  coordinates.push(coordinates[0]);\n\n  return coordinates;\n}\n\nexport default createGeodesicCircle;","import * as Constants from '../constants';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import createGeodesicFeature from '../utils/create_geodesic_geojson';\n\nfunction patchDrawLineString(DrawLineString) {\n  const DrawLineStringPatched = { ...DrawLineString };\n\n  DrawLineStringPatched.toDisplayFeatures = function(state, geojson, display) {\n    const displayGeodesic = (geojson) => {\n      const geodesicGeojson = createGeodesicFeature(geojson, { ctx: this._ctx });\n      geodesicGeojson.forEach(display);\n    };\n\n    DrawLineString.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n  };\n\n  return DrawLineStringPatched;\n}\n\nexport default patchDrawLineString;","import createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nfunction patchDrawPolygon(DrawPolygon) {\n  const DrawPolygonPatched = { ...DrawPolygon };\n\n  DrawPolygonPatched.toDisplayFeatures = function(state, geojson, display) {\n    const displayGeodesic = (geojson) => {\n      const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n      geodesicGeojson.forEach(display);\n    };\n    \n    DrawPolygon.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n  };\n\n  return DrawPolygonPatched;\n}\n\nexport default patchDrawPolygon;","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","const dragPan = {\n    enable(ctx) {\n        setTimeout(() => {\n            // First check we've got a map and some context.\n            if (!ctx.map || !ctx.map.dragPan || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n            // Now check initial state wasn't false (we leave it disabled if so)\n            if (!ctx._ctx.store.getInitialConfigValue('dragPan')) return;\n            ctx.map.dragPan.enable();\n        }, 0);\n    },\n    disable(ctx) {\n        setTimeout(() => {\n            if (!ctx.map || !ctx.map.doubleClickZoom) return;\n            // Always disable here, as it's necessary in some cases.\n            ctx.map.dragPan.disable();\n        }, 0);\n    },\n};\n\nexport default dragPan;","import * as CommonSelectors from '@mapbox/mapbox-gl-draw/src/lib/common_selectors';\nimport doubleClickZoom from '@mapbox/mapbox-gl-draw/src/lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport { createCircle, getCircleCenter } from '../utils/circle_geojson';\nimport { distance, initialBearing } from '../utils/geodesy';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\nimport dragPan from '../utils/drag_pan';\n\nconst DrawCircleGeodesic = {};\n\nDrawCircleGeodesic.onSetup = function(opts) {\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  dragPan.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.setActionableState(); // default actionable state is false for all actions\n  return {};\n};\n\nDrawCircleGeodesic.onMouseDown = DrawCircleGeodesic.onTouchStart = function(state, e) {\n  const center = [e.lngLat.lng, e.lngLat.lat];\n  const circle = this.newFeature(createCircle(center, Number.EPSILON));\n  this.addFeature(circle);\n  state.circle = circle;\n};\n\nDrawCircleGeodesic.onDrag = DrawCircleGeodesic.onTouchMove = function(state, e) {\n  if (state.circle) {\n    const geojson = state.circle.toGeoJSON();\n    const center = getCircleCenter(geojson);\n    const handle = [e.lngLat.lng, e.lngLat.lat];\n    const radius = distance(center, handle);\n    const handleBearing = initialBearing(center, handle);\n    state.circle.properties[Constants.properties.CIRCLE_RADIUS] = radius;\n    state.circle[Constants.properties.CIRCLE_HANDLE_BEARING] = handleBearing;\n    state.circle.changed();\n  }\n};\n\nDrawCircleGeodesic.onMouseUp = DrawCircleGeodesic.onTouchEnd = function(state, e) {\n  this.map.fire(Constants.events.CREATE, { features: [state.circle.toGeoJSON()] });\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.circle.id] });\n};\n\nDrawCircleGeodesic.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    if (state.circle) {\n      this.deleteFeature([state.circle.id], { silent: true });\n    }\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.circle.id] });\n  }\n};\n\nDrawCircleGeodesic.onStop = function() {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  dragPan.enable(this);\n  this.activateUIButton();\n}\n\nDrawCircleGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  if (state.circle) {\n    const isActivePolygon = geojson.properties.id === state.circle.id;\n    geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  }\n\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  displayGeodesic(geojson);\n};\n\nexport default DrawCircleGeodesic;","import createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nfunction patchDrawPoint(DrawPoint) {\n  const DrawPointPatched = { ...DrawPoint };\n\n  DrawPointPatched.toDisplayFeatures = function(state, geojson, display) {\n    const displayGeodesic = (geojson) => {\n      const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n      geodesicGeojson.forEach(display);\n    };\n\n    DrawPoint.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n  };\n\n  return DrawPointPatched;\n}\n\nexport default patchDrawPoint;","import createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nfunction patchSimpleSelect(SimpleSelect) {\n  const SimpleSelectPatched = { ...SimpleSelect };\n\n  SimpleSelectPatched.toDisplayFeatures = function(state, geojson, display) {\n    const displayGeodesic = (geojson) => {\n      const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n      geodesicGeojson.forEach(display);\n    };\n\n    SimpleSelect.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n  };\n\n  return SimpleSelectPatched;\n}\n\nexport default patchSimpleSelect;","import * as Constants from '../constants';\nimport { isCircle, getCircleCenter } from '../utils/circle_geojson';\nimport { distance, initialBearing } from '../utils/geodesy';\nimport createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\nfunction patchDirectSelect(DirectSelect) {\n  const DirectSelectPatched = { ...DirectSelect };\n\n  DirectSelectPatched.dragVertex = function(state, e, delta) {\n    const geojson = state.feature.toGeoJSON();\n\n    if (isCircle(geojson)) {\n      if (state.selectedCoordPaths[0] === '0.1') {\n        const center = getCircleCenter(geojson);\n        const handle = [e.lngLat.lng, e.lngLat.lat];\n        const radius = distance(center, handle);\n        const handleBearing = initialBearing(center, handle);\n        state.feature.properties[Constants.properties.CIRCLE_RADIUS] = radius;\n        state.feature[Constants.properties.CIRCLE_HANDLE_BEARING] = handleBearing;\n        state.feature.changed();\n      } else {\n        DirectSelect.dragFeature.call(this, state, e, delta);\n      }\n    } else {\n      DirectSelect.dragVertex.call(this, state, e, delta);\n    }\n  };\n\n  DirectSelectPatched.toDisplayFeatures = function(state, geojson, display) {\n    const displayGeodesic = (geojson) => {\n      const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx, selectedPaths: state.selectedCoordPaths });\n      geodesicGeojson.forEach(display);\n    };\n    \n    DirectSelect.toDisplayFeatures.call(this, state, geojson, displayGeodesic);\n  };\n\n  return DirectSelectPatched;\n}\n\nexport default patchDirectSelect;","import * as Constants from '../constants';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","import createGeodesicGeojson from '../utils/create_geodesic_geojson';\n\n// copied from https://github.com/mapbox/mapbox-gl-draw-static-mode\nconst StaticGeodesic = {};\n\nStaticGeodesic.onSetup = function() {\n  this.setActionableState(); // default actionable state is false for all actions\n  return {};\n};\n\nStaticGeodesic.toDisplayFeatures = function(state, geojson, display) {\n  const displayGeodesic = (geojson) => {\n    const geodesicGeojson = createGeodesicGeojson(geojson, { ctx: this._ctx });\n    geodesicGeojson.forEach(display);\n  };\n\n  displayGeodesic(geojson);\n};\n\nexport default StaticGeodesic;","\nimport * as Constants from '../constants';\nimport patchDrawLineString from './draw_line_string';\nimport patchDrawPolygon from './draw_polygon';\nimport DrawCircle from './draw_circle';\nimport patchDrawPoint from './draw_point';\nimport patchSimpleSelect from './simple_select';\nimport patchDirectSelect from './direct_select';\nimport Static from './static';\n\nexport function enable(modes) {\n    return {\n      ...modes,\n      [Constants.modes.DRAW_LINE_STRING]: patchDrawLineString(modes[Constants.modes.DRAW_LINE_STRING]),\n      [Constants.modes.DRAW_POLYGON]: patchDrawPolygon(modes[Constants.modes.DRAW_POLYGON]),\n      [Constants.modes.DRAW_CIRCLE]: DrawCircle,\n      [Constants.modes.DRAW_POINT]: patchDrawPoint(modes[Constants.modes.DRAW_POINT]),\n      [Constants.modes.SIMPLE_SELECT]: patchSimpleSelect(modes[Constants.modes.SIMPLE_SELECT]),\n      [Constants.modes.DIRECT_SELECT]: patchDirectSelect(modes[Constants.modes.DIRECT_SELECT]),\n      [Constants.modes.STATIC]: Static,\n    };\n  }"],"names":["cursors","geojsonTypes","events","meta","activeStates","modes","DRAW_LINE_STRING","DRAW_POLYGON","DRAW_POINT","SIMPLE_SELECT","DIRECT_SELECT","STATIC","DRAW_CIRCLE","properties","hat","hatModule","bits","base","undefined","digits","Math","log","pow","i","Infinity","rem","floor","res","random","toString","b","parsed","parseInt","rack","expandBy","fn","data","iters","Error","id","Object","hasOwnProperty","call","hats","get","set","value","createCircle","center","radius","type","Constants","geometry","coordinates","isCircle","geojson","getCircleCenter","getCircleRadius","D2R","PI","R2D","Coord","lon","lat","x","y","prototype","view","String","this","slice","antipode","anti_lat","anti_lon","LineString","coords","length","move_to","coord","push","Arc","geometries","json","multiline","wkt","wkt_string","collect","c","forEach","substring","GreatCircle","start","end","w","h","z","sin","cos","g","asin","sqrt","isNaN","interpolate","f","A","B","atan2","npoints","options","first_pass","delta","step","pair","bHasBigDiff","dfMaxSmallDiffLong","dfDateLineOffset","offset","dfLeftBorderX","dfRightBorderX","dfDiffSpace","j","dfPrevX","dfX","dfDiffLong","abs","poMulti","poNewLS","k","dfX0","parseFloat","dfX1","dfY1","dfX2","dfY2","tmpX","tmpY","dfRatio","dfY","poNewLS0","l","arc","m","line","points","j0","module","require$$0","coordinatesEqual","createGeodesicLine","steps","array","geodesicSegments","map","index","filter","segment","worldOffset","geodesicCoordinates","geodesicSegment","prevWorldOffset","nextWorldOffset","flat","toRadians","toDegrees","initialBearing","destination","position1","position2","Number","EPSILON","NaN","φ1","φ2","Δλ","bearing","DEFAULT_RADIUS","distance","R","λ1","Δφ","a","geodesyDistance","destinationPoint","δ","θ","sinφ2","λ2","geodesyDestinationPoint","getCoordinate","path","coordinate","split","reduce","JSON","parse","stringify","createGeodesicGeojson","featureId","parent","feature","ctx","store","featureGeojson","toGeoJSON","coordPath","coord_path","coordPathIds","startCoordPath","join","endCoordPath","startCoord","endCoord","midCoord","C","φm","λm","midpoint","lng","processMidpoint","processLine","handleBearing","createGeodesicCircle","geodesicGeojson","active","point","parentId","selected","createVertex","selectedPaths","indexOf","isSelectedPath","processCircle","subCoordinates","processPolygon","subType","replace","subFeature","processMultiGeometry","patchDrawLineString","DrawLineString","DrawLineStringPatched","toDisplayFeatures","state","display","createGeodesicFeature","_ctx","patchDrawPolygon","DrawPolygon","DrawPolygonPatched","enable","setTimeout","doubleClickZoom","getInitialConfigValue","disable","dragPan","DrawCircleGeodesic","patchDrawPoint","DrawPoint","DrawPointPatched","patchSimpleSelect","SimpleSelect","SimpleSelectPatched","patchDirectSelect","DirectSelect","DirectSelectPatched","dragVertex","e","selectedCoordPaths","handle","lngLat","changed","dragFeature","onSetup","opts","clearSelectedFeatures","updateUIClasses","mouse","setActionableState","onMouseDown","onTouchStart","circle","newFeature","addFeature","onDrag","onTouchMove","onMouseUp","onTouchEnd","fire","features","changeMode","featureIds","onKeyUp","keyCode","CommonSelectors","deleteFeature","silent","onStop","activateUIButton","isActivePolygon","displayGeodesic","StaticGeodesic","DrawCircle","Static"],"mappings":"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"}